---
layout: single
title:  "Lazy Divide and Conquer"
date:   2021-07-14 18:31:14 -0400
categories: contest
---

{% include mathjax.html %}

Hi all!

Today I'll be presenting a simple, but interesting Divide and Conquer trick that lets you
process 2D range updates and range queries quickly and with low memory usage.

The basis of this form of Divide and Conquer is the segment tree, except instead of being used to process queries and
 updates online, we'll be traversing the segment tree im a way similar to a BFS or DFS search.  This allows us to use a
1D data structure to compute the answers to each query.  This usually results in an improved memory complexity (usually
by a log factor) along with a smaller hidden constant in the time complexity (which I believe is due to better cache
locality).

To motivate the algorithm, I'll present a sample problem:

> Given an $$N \times N$$ grid $$A$$ (all initially zeros), process $$Q$$ queries of the following types:
> 1. Given the integers $$l,r,d,u,v$$, assign $$A_{i,j} := A_{i,j} + v$$ for all $$l \le i \le r, d \le j \le u$$
> 2. Given the integers $$l,r,d,u$$, output the value $$\sum_{i=l}^r \sum_{j=d}^u A_{i,j}$$

The time complexity of the solution should be $$\mathcal{O}(N \log^2{N})$$ and the memory complexity should be
$$\mathcal{O}(N \log{N})$$.

![segment tree picture](https://raw.githubusercontent.com/e-maxx-eng/e-maxx-eng/master/img/sum-segment-tree.png)


d

If you are also in need of some code here is a [problem (and solution)](https://mosesxu.ca/dmojsols/view/coci18c2p5/cpp) that uses this technique if you
are curious.

# Extra Notes

The biggest note I have for the blog is (surprisingly enough) the hidden constant of the runtime.  While in my experience,
this trick is preferable to using 2D data structures such as sparse fenwick tree, 2D segment tree, and
 segment tree of binary search trees, it still has a large constant factor.  This is because updates have be done and
undone multiple times, which means your 1D data structure needs to be very efficient for a low runtime.  This also
means that for some coders who are very advanced with 2D data structures, this trick may not improve runtime.

Additionally, I want to note the motivation I had for this trick.  The non-lazy version (where you only have to process
point updates), is (to my understanding) a well-known trick first presented by CDQ in her China TST Paper from 2008.
Meanwhile, the lazy version was just the result of me slapping together CDQ Divide and Conquer with some funny segment tree
 shenanigans :)